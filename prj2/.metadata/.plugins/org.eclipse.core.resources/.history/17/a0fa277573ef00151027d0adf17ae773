//! 
//# c6x1x.cdb 5.25.25

object CACHE_L2 :: MEM {
    param iComment :: "Generated by Cache Settings in GBL"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 262144
    param len :: 0
    param iAllocHeap :: 0
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "Cache"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (if self.gNumOf > 0 {1} else {0})
    prop NoGen :: 0
    prop IsDirty :: ($a = self.gDirty, self.gDirty = 0, $a)
    prop dataSize :: 0
    prop error :: # ("Error: ", self.name, $1)
    prop warning :: ("Warning ...", self.name, $1)
    prop minBit :: ($a = 0, while (($1 & (1 << $a)) && $a < 32) {++$a}, $a)
    prop name :: ("<unnamed module>")
    prop numBit :: ($a = $b = 0, while ($a < 32) {if ($1 & (1 << $a)) {++$b} }, $b)
}

class ObjectMgr {
    isa Module
    prop CanCreate :: (if (self.gNumOf < self.maxObjs()) {self.localCanCreate()} else {self.warning("Maximum number of objects already created")})
    prop CanDelete :: (if (self.iDelMsg == "ok" || (self.iDelUser == self.gUser)) {if (self.iId >= 0 && self.iIsUsed) {self.localCanDelete()} else {self.warning("Object already deleted")}} else {self.warning(self.iDelMsg)})
    prop Create :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanCreate()) == "ok") {if (($a = self.localCreate()) == "ok") {if (self.iIsUsed == 0) {self.mkId(if $0 > 1 {$2} else {-1}), self.iIsUsed = 1, GlobalStatus.gDirty = 1, self.gDirty = 1} } } , (self.gUser = "USER"), $a)
    prop Delete :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanDelete()) == "ok") {if (($a = self.localDelete()) == "ok") {self.rmId(self.iId), self.iIsUsed = 0, GlobalStatus.gDirty = 1, self.gDirty = 1} } , (self.gUser = "USER"), $a)
    prop GetSetOf :: (self.gSetOf)
    prop GetNumOf :: (self.gNumOf)
    prop GetObjId :: (self.iId)
    prop GetPriority :: (self.iId)
    prop SetPriority :: (self.iId = $1)
    prop IsConfObj :: (self.iIsUsed)
    prop localCanCreate :: ("ok")
    prop localCanDelete :: ("ok")
    prop localCreate :: ("ok")
    prop localDelete :: ("ok")
    prop localInit :: (0)
    prop isFinite :: (if self.maxObjs() <= GBL.DSPWORDSIZE {1} else {0})
    prop mkId :: (if (self.isFinite()) {if ($1 < 0) {self.iId = self.minBit(self.gSetOf)} else {self.iId = $1}, (self.gSetOf |= (1 << self.iId))} else {self.iId = 0}, ++self.gNumOf, self.iId)
    prop rmId :: (if (self.isFinite()) {self.gSetOf &= ~(1 << self.iId)} , --self.gNumOf)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop isDriver :: (0)
    prop SortChildHierView :: (1)
}

type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (100)
    prop GlobalPropertyPage :: ("{9D3AD931-847B-11d0-A621-0000C070F3E9}")
    prop Status :: (# self.SeedVersion, # self.MinStackSize, # self.SysDataSize)
    global GENLIB :: "bioscfg.dll" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generation Library"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    global DATE :: "Mon Mar 21 14:44:15 2016" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global GCONFVERS :: "@(#)*** xdcutils-e03" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SysDataSize :: = ($a = 0, scan ($i; nil) {if ($i.dataSize() != nil) {$a = $a + $i.dataSize()} }, $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Estimated Data Size: %d"
        prop StatusField :: 1
        prop NoGen :: 1
    }
    global MinStackSize :: = ($a = ((2 * (2)) * 4), $a = $a + ((2 * (5)) * 4), $a = $a + ((0) * 4), $b = 0, scan ($i; CLK) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (2)) * 4) * $b), $b = 0, scan ($i; HWI) {if ($i.IsConfObj()) {if ($i != HWI_NMI && $i != HWI_RESET) {if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {$b++} } } }, $a = $a + (((12 + 14 + 2) * 4) * $b), $b = 0, scan ($i; SWI) {if ($i.IsConfObj()) {if ($i.priority > $b) {$b = $i.priority} } }, $a = $a + ((((2 * 2) + 18 + (2 * 4)) * 4) * $b), $b = 0, scan ($i; PRD) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (3)) * 4) * $b), $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Est. Min. Stack Size (MAUs): %d"
        prop StatusField :: 1
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ConfigWarnings :: = (if (self.MinStackSize > MEM.STACKSIZE) {"Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."} else {"None"}) { 
        prop Label :: "Warnings"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SeedVersion :: = "@(#)*** cuda-u25x" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

class EModule {
    isa Module
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class ModuleFolder {
    isa Module
    prop NoGen :: 1
}

type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (500)
    prop GlobalPropertyPage :: ("{B936FB91-52A5-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (501)
    prop GlobalPropertyPage :: ("{053C8F90-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (502)
    prop GlobalPropertyPage :: ("{053C8F91-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (503)
    prop GlobalPropertyPage :: ("{053C8F92-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (504)
    prop GlobalPropertyPage :: ("{053C8F93-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (505)
    prop GlobalPropertyPage :: ("{A2BCEC70-5365-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type PROJ {
    isa ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (201)
    prop GlobalHelpTopic :: (101)
    prop InstancePropertyPage :: ("{AC3C77D1-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D2-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ALIASALL :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate C Names for All Objects"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global IGNOREWARNING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Ignore Warnings"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Include File Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global OBJDIR :: "." { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object file directory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTEXE :: "out" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Executable File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTLIB :: "lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTASM :: "asm" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Assembly Language Source File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTOBJ :: "obj" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst projType :: "Executable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Executable,Library"
        prop Label :: "Target Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst projName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst useRpt :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RPT Instruction"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst minimizeSpace :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Optimize for Space over Time"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst tmx :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Avoid TMX Silicon Bugs"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    prop Label :: "Project File Manager"
    prop InstanceHelpTopic :: (BIOSHELP_PROJ_FILE_INSTANCE)
    prop GlobalHelpTopic :: (BIOSHELP_PROJ_FILE_GLOBAL)
    prop InstancePropertyPage :: ("{AC3C77D3-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D4-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst elemType :: "C Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C Source,ASM Source,Library,Linker Command File"
        prop Label :: "Input File Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Input File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "register,register+local,register+local+global,register+local+global+file"
        prop Label :: "Optimization Level"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst inline :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Inline Expansion"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst definitions :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Additional Definitions"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst iParent :: 0 { 
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 0
    prop GenLinkPrologue :: ("%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n--trampolines\n%25S%1S%22S-l%2S%23S%3S\n%24S%15S%4S%16S%18S%5S%6S%12S%7S%17S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _librarySuffix, _chipStr, _sioLibStr, _mpcLibStr, _bios6xLibStr, _bios6xClkType, _instStr, _rtsNameStr, _romStr, _biosRomStr, _logLibStr, _SKLibStr")
    prop poolStr :: (if (self.LINKWITHROM == 0) {""} else {if POOL.USEPOOL {""} else {"_POOL_config=0;\n"}})
    prop msgqStr :: (if (self.LINKWITHROM == 0) {""} else {if MSGQ.USEMSGQ {""} else {"_MSGQ_config=0;\n"}})
    prop GenLinkEpilogue :: ("%0t_GBL_CACHE = GBL_CACHE;\n%1S%2S\0, poolStr, msgqStr")
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
    prop GlobalHelpTopic :: (103)
    prop InstanceHelpTopic :: (103)
    prop InstancePropertyPage :: ("{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}")
    prop localInit :: (RTA_toHost.Create("HST"), RTA_toHost.bufseg = HST.OBJMEMSEG, RTA_fromHost.Create("HST"), RTA_fromHost.bufseg = HST.OBJMEMSEG, RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"))
    prop chipcall :: ("ok")
    prop IsConfMod :: 1
    prop ucompare :: ($e = "ok", $a = ($1 >> 31) & 0x00000001, $b = ($2 >> 31) & 0x00000001, $c = $1 & 0x7fffffff, $d = $2 & 0x7fffffff, if ($a > $b) {$e = "gt"} else {if ($a == $b) {if ($c > $d) {$e = "gt"} else {if ($c == $d) {$e = "eq"} else {$e = "lt"}}} else {$e = "lt"}}, $e)
    prop L2Check :: (if (self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711) {self.PCC = "mapped", if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} , self.L2CacheSizeCheck()} else {if (self.DSPSUBTYPE == 6400) {self.PCC = "mapped", if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} , self.L2CacheSizeCheck()} else {if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0, self.L2CacheSizeCheck()} else {if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0, self.L2CacheSizeCheck()} }}})
    prop C621xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C621XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "SRAM") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "1-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x4000, CACHE_L2.len = 0x4000} else {if (self.L2MODEOPTS == "2-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.L2MODEOPTS == "3-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0xc000, CACHE_L2.len = 0xc000} else {if (self.L2MODEOPTS == "4-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} }}}}}, $e)
    prop C641xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C641XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (0k)") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C641XL2MODEOPTS == "4-way cache (256k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} }}}}}, $e)
    prop C64PL1PCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1PCFG = "32k", CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {if (self.C64PL1PCFG == "0k") {CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x0, CACHE_L1P.len = 0x0, CACHE_L1P.Delete("MEM")} else {if (self.C64PL1PCFG == "4k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x1000, CACHE_L1P.len = 0x1000} else {if (self.C64PL1PCFG == "8k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x2000, CACHE_L1P.len = 0x2000} else {if (self.C64PL1PCFG == "16k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x4000, CACHE_L1P.len = 0x4000} else {if (self.C64PL1PCFG == "32k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL1DCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1DCFG = "32k", CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {if (self.C64PL1DCFG == "0k") {CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x0, CACHE_L1D.len = 0x0, CACHE_L1D.Delete("MEM")} else {if (self.C64PL1DCFG == "4k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x1000, CACHE_L1D.len = 0x1000} else {if (self.C64PL1DCFG == "8k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x2000, CACHE_L1D.len = 0x2000} else {if (self.C64PL1DCFG == "16k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x4000, CACHE_L1D.len = 0x4000} else {if (self.C64PL1DCFG == "32k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL2CacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "0k") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "32k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C64PL2MODEOPTS == "64k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C64PL2MODEOPTS == "128k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C64PL2MODEOPTS == "256k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} else {if (self.C64PL2MODEOPTS == "512k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x80000, CACHE_L2.len = 0x80000} else {if (self.C64PL2MODEOPTS == "1024k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x100000, CACHE_L2.len = 0x100000} else {$e = self.error("Unknown cache size")}}}}}}}}, $e)
    prop L2CacheSizeCheck :: ($e = "ok", scan ($i; MEM) {if ($i == CACHE_L2) {if self.C621XL2CONFIGURE {$e = self.C621xL2CacheSizeCheck()} else {if self.C641XL2CONFIGURE {$e = self.C641xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711 {$e = self.C621xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6400 {$e = self.C641xL2CacheSizeCheck()} else {{CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")}}}}}} }, $e)
    prop setCPUClock :: ($e = "ok", if ($1 != self.CPUCLOCK) {$a = self.CPUCLOCK, self.CPUCLOCK = $1, if (GBL.CALLBACKOBJ != nil) {$e = GBL.CALLBACKOBJ.call()} , if ($e != "ok") {self.CPUCLOCK = $a, GBL.CALLBACKOBJ.call()} } , if ($e == "ok") {"ok"} else {self.error($e)})
    prop setL2MODE :: (if (self.L2MODEOPTS == "SRAM") {0x0} else {if (self.L2MODEOPTS == "1-way cache") {0x1} else {if (self.L2MODEOPTS == "2-way cache") {0x2} else {if (self.L2MODEOPTS == "3-way cache") {0x3} else {0x7}}}})
    prop setC641XL2MODE :: (if (self.C641XL2MODEOPTS == "4-way cache (0k)") {0x0} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {0x1} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {0x2} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {0x3} else {0x7}}}})
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (if (HST.RTDX == 1) {"lnkrtdx"} else {if (HST.DSM == 1) {"lnkdsm"} else {if (HST.EVM54 == 1) {"lnkevm54"} else {if (HST.BIOSLINK == 1) {"lnkbioslink"} else {"lnknone"}}}})
    prop _dsptype :: GBL.DSPTYPE
    prop _instStr :: if self.INSTRUMENTED {""} else {"_NONINST"}
    prop _rtsNameStr :: (self.RTSLIB)
    prop _biosLibStr :: "-lbios%20S%23S%8S %24t/* DSP/BIOS support */%0t\n"
    prop _compilerModel :: if self.ENDIAN == "big" {"e"} else {""}
    prop _librarySuffix :: (if (self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711 || self.DSPSUBTYPE == 6712 || self.DSPSUBTYPE == 6713) {if (self.ENDIAN == "big") {".a67e"} else {".a67"}} else {if (self.DSPSUBTYPE == 6400) {if (self.ENDIAN == "big") {".a64e"} else {".a64"}} else {if (self.DSPSUBTYPE == 6499) {if (self.ENDIAN == "big") {".a64Pe"} else {".a64P"}} else {if (self.DSPSUBTYPE == 6799) {if (self.ENDIAN == "big") {".a67Pe"} else {".a67P"}} else {if ((self.DSPSUBTYPE == 6747) || (self.DSPSUBTYPE == 6748)) {if (self.ENDIAN == "big") {".a674e"} else {".a674"}} else {if (self.ENDIAN == "big") {".a62e"} else {".a62"}}}}}})
    prop _rtdxLibStr :: if RTDX.USERTDX == 0 {""} else {if RTDX.RTDXTYPE == "JTAG" {"-lrtdx%9S.lib %24t/* RTDX support */%0t\n"} else {if RTDX.RTDXTYPE == "Simulator" {"-lrtdxsim%9S.lib %24t/* RTDX support */%0t\n"} else {"-lrtdxhs%9S.lib %24t/* RTDX support */%0t\n"}}}
    prop _rtsLibStr :: (if self.SPECIFYRTSLIB {"-l%21S%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711 || self.DSPSUBTYPE == 6712 || self.DSPSUBTYPE == 6713 {"-lrts6700%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6400 {"-lrts6400%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6799 {"-lrts67plus%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6499 {"-lrts64plus%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if ((self.DSPSUBTYPE == 6747) || (self.DSPSUBTYPE == 6748)) {"-lrts6740%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {"-lrts6200%9S.lib%24t/* C and C++ run-time library support */%0t\n"}}}}}})
    prop _bios6xClkType :: (if self.CLKTYPE == 6000 {"C6000"} else {if self.CLKTYPE == 700 {"DA700"} else {if (self.CLKTYPE == 420 || self.CLKTYPE == 6424) {if self.USEIDMA0DISPATCHER {"DM420IDMA0"} else {"DM420"}} else {if self.CLKTYPE == 2430 {"2430"} else {if self.CLKTYPE == 6482 {"TCI6482"} else {if self.CLKTYPE == 6486 {"TCI6486"} else {if self.CLKTYPE == 6488 {"TCI6488"} else {if self.CLKTYPE == 442 {"DRA442"} else {if self.CLKTYPE == 3430 {"3430"} else {if self.CLKTYPE == 6467 {"DM6467"} else {if self.CLKTYPE == 761990 {"F761990"} else {""}}}}}}}}}}})
    prop _bios6xLibStr :: ("-lbios%19S%8S%24t/* BIOS clock specific library */%0t\n-lbios6x1x%8S%24t/* BIOS c6x1x specific library */%0t\n")
    prop _chipStr :: ""
    prop _pmiLibStr :: ""
    prop _pmiVoltLibStr :: ""
    prop _pmiVoltControlLibStr :: ""
    prop _psclLibStr :: ""
    prop _psclCfgLibStr :: ""
    prop _psclConfigLibStr :: ""
    prop _mpcLibStr :: ""
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (if (MEM.LNKCMDFILE == "") {""} else {"-l%11S %24t/* User Specified Linker cmd file */%0t\n"})
    prop _sioLibStr :: if SIO.USEISSUERECLAIM == 1 {"-lsioir%23S%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n"} else {"-lsioboth%23S%8S %24t/* supports both SIO models */%0t\n"}
    prop _devLibStr :: "-ldrivers%23S%14S %24t/* device drivers support */%0t\n"
    prop _cslLibStr :: ""
    prop _chipType :: ""
    prop _logLibStr :: if LOG.TS {"-llog8%3S\n"} else {""}
    prop _romStr :: if self.LINKWITHROM {"-lromC672x.out\n-lromC672x.cmd\n"} else {""}
    prop _biosRomStr :: if self.LINKWITHROM {"_BIOSROM"} else {""}
    prop _SKLibStr :: ""
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PRODUCT :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop EnvField :: 1
    }
    global CALLBACKOBJ :: CLK { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c6211" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CPUCLOCK :: 225.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PROCID :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Processor ID (PROCID)"
        prop JSName :: "PROCID"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CLKIN :: = 20000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: "Board Clock in KHz (Informational Only)"
        prop JSName :: "CLKIN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global FREQ :: 225000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MIPS :: 225.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = self.MIPS, $b = if (GBL.DSPTYPE == 62) {$1} else {$1 * 2}, $e = "ok", self.MIPS = $1, self.FREQ = int(self.MIPS * 1000), if (($e = self.setCPUClock($b)) != "ok") {self.MIPS = $a} , $e)
    }
    global OSTYPE :: "BIOS" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPTYPE :: 62 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global SPECIFYRTSLIB :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify RTS library"
        prop JSName :: "SPECIFYRTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
    }
    global RTSLIB :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Run-Time Support Library"
        prop JSName :: "RTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: self.SPECIFYRTSLIB
    }
    global DSPSUBTYPE :: 6713 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "6211,6711,6712,6713"
        prop Label :: "DSP Type"
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (self.DSPSUBTYPE = $1, self.L2Check(), "ok")
        prop NoGen :: 0
    }
    global CLKTYPE :: 6000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CLK Type"
        prop JSName :: "CLKTYPE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CHIPTYPE :: "6713" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "6211,6711,6712,6713,DA610,custom,other"
        prop Label :: "Chip Support Library (CSL)"
        prop JSName :: "CHIPTYPE"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (if ($1 == "6201" || $1 == "6202" || $1 == "6203" || $1 == "6204" || $1 == "6205") {self.DSPSUBTYPE = 6200} else {if ($1 == "6701") {self.DSPSUBTYPE = 6700} else {if ($1 == "6211") {self.DSPSUBTYPE = 6211} else {if ($1 == "6711" || $1 == "6712" || $1 == "6713" || $1 == "DA610") {if ($1 == "6711") {self.DSPSUBTYPE = 6711} , if ($1 == "6712") {self.DSPSUBTYPE = 6712} , if ($1 == "6713") {self.DSPSUBTYPE = 6713} } else {if ($1 == "DM642" || $1 == "6412" || $1 == "6414" || $1 == "6415" || $1 == "6416" || $1 == "6410" || $1 == "6413") {self.DSPSUBTYPE = 6400} }}}}, self.CHIPTYPE = $1, self.L2Check(), $e = "ok", if (GBL.CHIPCHAIN != nil) {$e = GBL.CHIPCHAIN.chipcall()} , $e)
    }
    global DISPCALLCSLCFGINIT :: = (self.CHIPTYPE != "other" && self.CHIPTYPE != "custom") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: self.SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C62XX" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPARITHMETIC :: = (if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {"FLOAT"} else {"FIXED"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {32} else {16}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (if GBL.DSPTYPE == 62 {8} else {if GBL.DSPSUBTYPE == 5599 {8} else {GBL.DSPWORDSIZE}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DATAPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {16} else {if (GBL.DSPTYPE == 55) {if (GBL.MEMORYMODEL == "SMALL") {16} else {23}} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {if (GBL.CALLMODEL == "near") {16} else {24}} else {if (GBL.DSPTYPE == 55) {24} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENDIAN :: "little" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "little,big"
        prop Label :: "DSP Endian Mode"
        prop JSName :: "ENDIANMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.ENDIAN = $1, "ok")
    }
    global BIGENDIAN :: = if self.ENDIAN == "little" {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global AUTOINIT :: "ROM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {self.USERINITFXN = @_FXN_F_nop, self.USERINIT = $1} else {self.USERINIT = $1}, "ok")
    }
    global USERINITFXN :: @_GBL_setPLLto225MHz { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: self.USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENABLEINST :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEINST) {if ($1) {RTA_toHost.Create("HST"), RTA_toHost.bufseg = HST.OBJMEMSEG, RTA_fromHost.Create("HST"), RTA_fromHost.bufseg = HST.OBJMEMSEG, RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = self.OLDAUTOCALCULATE} else {if (self.LINKWITHROM) {self.LINKWITHROM = 0} , RTA_toHost.Delete("HST"), RTA_toHost.bufseg = MEM_NULL, RTA_fromHost.Delete("HST"), RTA_fromHost.bufseg = MEM_NULL, RTA_dispatcher.Delete("HST"), IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), self.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0}, self.ENABLEINST = $1} , "ok")
    }
    global INSTRUMENTED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Instrumented BIOS library"
        prop JSName :: "INSTRUMENTED"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CGENERATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLEDLL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Dynamic Loading"
        prop JSName :: "ENABLEDLL"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global PCC :: "mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Program Cache Control - CSR(PCC)       "
        prop JSName :: "CSRPCC"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6400) {0} else {1}
        prop NoGen :: 1
        prop TabName :: "620x/670x/672x"
    }
    global DCC :: "mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Data Cache Control"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "620x/670x/672x"
    }
    global PCACHE :: = (if (self.PCC == "mapped") {0x0000} else {if (self.PCC == "cache enable") {0x0040} else {if (self.PCC == "cache freeze") {0x0060} else {0x0080}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DCACHE :: = (if (self.DCC == "mapped") {0x0000} else {if (self.DCC == "cache enable") {0x0008} else {if (self.DCC == "cache freeze") {0x000c} else {0x0010}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CACHE :: = (self.PCACHE | self.DCACHE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global C621XL2CONFIGURE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "621x/671x - Configure L2 Memory Settings"
        prop JSName :: "C621XCONFIGUREL2"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6712 || GBL.DSPSUBTYPE == 6713) {1} else {0}
        prop TabName :: "621x/671x"
        prop Set :: ($e = "ok", self.C621XL2CONFIGURE = $1, self.PCC = "mapped", $e = self.L2CacheSizeCheck(), $e)
        prop NoGen :: 1
    }
    global C641XL2CONFIGURE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x - Configure L2 Memory Settings"
        prop JSName :: "C641XCONFIGUREL2"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400) {1} else {0}
        prop TabName :: "641x"
        prop Set :: ($e = "ok", self.C641XL2CONFIGURE = $1, self.PCC = "mapped", $e = self.L2CacheSizeCheck(), $e)
        prop NoGen :: 1
    }
    global L2CONFIGURE :: = (if GBL.DSPSUBTYPE == 6400 {self.C641XL2CONFIGURE} else {self.C621XL2CONFIGURE}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure L2 Cache Control (c6x1x support)"
        prop Visible :: 0
        prop NoGen :: 0
    }
    global C621XPCC :: "Cache Enabled - Direct Mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "Program Cache Control - CSR(PCC)                     "
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "621x/671x"
    }
    global C641XPCC :: "Cache Enabled - Direct Mapped" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "641x - Program Cache Control - CSR(PCC)"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2MODEOPTS :: "SRAM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Mode - CCFG(L2MODE)"
        prop JSName :: "C621XCCFGL2MODE"
        prop Enum :: "SRAM,1-way cache,2-way cache,3-way cache,4-way cache"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6712 || GBL.DSPSUBTYPE == 6713) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "621x/671x"
        prop Set :: ($i = self.L2MODEOPTS, self.L2MODEOPTS = $1, $e = self.L2CacheSizeCheck(), if ($e != "ok") {self.L2MODEOPTS = $i} , $e)
    }
    global C641XL2MODEOPTS :: "4-way cache (0k)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x L2 Mode - CCFG(L2MODE)"
        prop Enum :: "4-way cache (0k),4-way cache (32k),4-way cache (64k),4-way cache (128k),4-way cache (256k)"
        prop JSName :: "C641XCCFGL2MODE"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
        prop Set :: ($i = self.C641XL2MODEOPTS, self.C641XL2MODEOPTS = $1, $e = self.L2CacheSizeCheck(), if ($e != "ok") {self.C641XL2MODEOPTS = $i} , $e)
    }
    global L2MODE :: = (if GBL.DSPSUBTYPE == 6400 {self.setC641XL2MODE()} else {self.setL2MODE()}) { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Mode - CCFG(L2MODE) Values"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2PRIORITY :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Requestor Priority - CCFG(P)"
        prop Enum :: "0,1"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2MARMASK :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "L2 MAR0-15 - bitmask used to initialize MARs"
        prop JSName :: "C621XMAR"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 || GBL.DSPSUBTYPE == 6712 || GBL.DSPSUBTYPE == 6713) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "621x/671x"
    }
    global SUPPORTCSL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.TRCMASKVALUE = 0xDBEF} else {self.TRCMASKVALUE = 0x4000}, self.ENABLEALLTRC = $1, "ok")
    }
    global TRCMASKVALUE :: 56303 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT :: = self.DISPCALLCSLCFGINIT { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LINKWITHROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link with ROM"
        prop JSName :: "LINKWITHROM"
        prop Visible :: 0
        prop Writable :: if (self.DSPSUBTYPE == 6799 && self.ENABLEINST) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1) {$e = self.error("This BIOS version does not support linking with ROM.")} , $e)
    }
    global C641XL2PRIORITY :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK1 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR96-111 - bitmask controls EMIFB CE space"
        prop JSName :: "C641XMAREMIFB"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK2 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR128-143 - bitmask controls EMIFA CE0 space"
        prop JSName :: "C641XMARCE0"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK3 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR144-159 - bitmask controls EMIFA CE1 space"
        prop JSName :: "C641XMARCE1"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK4 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR160-175 - bitmask controls EMIFA CE2 space"
        prop JSName :: "C641XMARCE2"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2MARMASK5 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR176-191 - bitmask controls EMIFA CE3 space"
        prop JSName :: "C641XMARCE3"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2REQPRIORITY :: "urgent" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x L2 Requestor Priority Queue - CCFG(P)"
        prop JSName :: "C641XCCFGP"
        prop Enum :: "urgent,high,medium,low"
        prop Visible :: 1
        prop Writable :: if ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop Set :: (self.L2REQPRIORITY = $1, if (self.L2REQPRIORITY == "urgent") {self.C641XL2PRIORITY = 0} else {if (self.L2REQPRIORITY == "high") {self.C641XL2PRIORITY = 1} else {if (self.L2REQPRIORITY == "medium") {self.C641XL2PRIORITY = 2} else {self.C641XL2PRIORITY = 3}}}, "ok")
        prop TabName :: "641x"
    }
    global L2CONFIGALLOC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure Priority Queues"
        prop JSName :: "C641XSETL2ALLOC"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1)
        prop NoGen :: 0
        prop TabName :: "641x"
    }
    global L2ALLOC0 :: 6 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on URGENT Queue (L2ALLOC0)"
        prop JSName :: "C641XL2ALLOC0"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC1 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on HIGH Queue (L2ALLOC1)"
        prop JSName :: "C641XL2ALLOC1"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC2 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on MEDIUM Queue (L2ALLOC2)"
        prop JSName :: "C641XL2ALLOC2"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC3 :: 2 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Max L2 Transfer Requests on LOW Queue (L2ALLOC3)"
        prop JSName :: "C641XL2ALLOC3"
        prop Enum :: "0,1,2,3,4,5,6,7"
        prop Visible :: 1
        prop Writable :: if (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 && GBL.L2CONFIGALLOC == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2ALLOC :: = ((self.L2ALLOC0) | (self.L2ALLOC1 << 4) | (self.L2ALLOC2 << 8) | (self.L2ALLOC3 << 12)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 0
    }
}

type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (108)
    prop InstanceHelpTopic :: (208)
    prop InstancePropertyPage :: ("{3D658E70-05E7-11d0-BD44-0020AFEE33C8}")
    prop GlobalPropertyPage :: ("{3D658E71-05E7-11d0-BD44-0020AFEE33C8}")
    prop heapLabelStr :: (self.iHeapId)
    prop GenLinkPrologue :: (if (GBL.DSPTYPE == 55) {"-stack 0x%1x\n-sysstack 0x%2x\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz"} else {"-stack 0x%1x\nMEMORY {%4t\0, _stackSize"})
    prop _stackSize :: MEM.STACKSIZE
    prop AllocType :: (if (self.REUSE == 0 && self.USERCMD == 0) {"19\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 0 && self.USERCMD == 1) {"9\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 1 && self.USERCMD == 0) {"18\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {"8\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"}}})
    prop _firstPlace :: 0
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace :: (0x7fffffff / 2)
    prop _sysinitPlace :: (0x7fffffff / 2)
    prop _argsString :: ("%8t .args: align=4 fill=0 {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString :: ("%8t .bss:     {}")
    prop _farString :: ("%8t .far:     {}")
    prop _cinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CINITSEG == MEM.LOADCINITSEG) {"%8t .cinit:    {}"} else {"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"}} else {"%8t .cinit:    {}"})
    prop _pinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.PINITSEG == MEM.LOADPINITSEG) {"%8t .pinit:   {}"} else {"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"}} else {"%8t .pinit:   {}"})
    prop _trcinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {"%8t .trcdata:   {}"} else {"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"}} else {"%8t .trcdata:    {}"})
    prop _gblinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {"%8t .gblinit:   {}"} else {"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"}} else {"%8t .gblinit:    {}"})
    prop _dataString :: ("%8t .data:    {}")
    prop _constString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {"%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"} else {"%8t .const: align = 0x8 {} load > %1s run\0, _loadconstSeg"}} else {"%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"})
    prop _switchString :: (if (self.ENABLELOADSEG == 1) {if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {"%8t .switch:   {}"} else {"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"}} else {"%8t .switch:    {}"})
    prop _sysmemString :: ("%8t .sysmem:  {}")
    prop _cioString :: ("%8t .cio:     {}")
    prop _memObjString :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (if ((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {"%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"} else {"%8t .sysdata: {}"})
    prop _sysinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.INITSEG == MEM.LOADINITSEG) {"%8t .sysinit:   {}"} else {"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"}} else {"%8t .sysinit:    {}"})
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {"%8t .text:    {}"} else {"%8t .text:    {} load > %1s, run\0, _loadtextSeg"}} else {"%8t .text:    {}"})
    prop _frtString :: ("%8t frt:    {}")
    prop _biosString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {"%8t .bios:    {}"} else {"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"}} else {"%8t .bios:    {}"})
    prop _stackString :: (if (GBL.DSPTYPE == 62) {"%8t .stack: align = 0x8 {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 8;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"} else {if (GBL.DSPTYPE == 54) {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"} else {if (GBL.DSPTYPE == 55) {"%8t GROUP { \n%16t .sysstack :  align = 0x4 {%12t\n %16t GBL_sysstackbeg = .;\n %16t *(.sysstack)\n %16t GBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n %16t _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n %16t_HWI_SYSSTKBOTTOM = (GBL_sysstackend+1);\n%16t} \n%16t .stack: align = 0x4 {%12t\n %16t GBL_stackbeg = .;\n %16t *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n %16t _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n %16t _HWI_STKTOP = (GBL_stackbeg);%16t\n }%8t\n } BLOCK(0x20000), run \0, _cmd55stksz, _cmd55systksz"} else {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"}}})
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: ("%0t}")
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (if (self.iAllocHeap == 1) {"1\0, _instAllocDesc, _objMemSeg, _placement"} )
    prop _instAllocDesc :: (if self.INITSEG.iAllocHeap && self.REUSE && self.INITSEG == self {"%8t GROUP {%12t\n .sysinitgap {. += 0x%2x;}\n .sysinit:\n .%0r$heap: {%16t\n . += 0x%1x;%12t\n }%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _sysinitgap, _heaplen"} else {"%8t .%0r$heap: {%12t\n . += 0x%1x;%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _heaplen"})
    prop _objMemSeg :: self
    prop _placement :: 0x7fffffff - 1
    prop _heapsize :: (self.iHeapSize)
    prop _heaplen :: (self.iHeapSize)
    prop _sysinitgap :: 2 * 4
    prop GenInstLink :: (if GBL.DSPTYPE == 62 {"%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"} else {if GBL.DSPTYPE == 55 {"PAGE %3d: %16t%0r: %26torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len, _page"} else {"PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"}})
    prop localInit :: ($d = "ok", scan ($i; MEM) {if ($i.space == "code" && $i.iAllocHeap == 1) {$d = self.error("Code memory cannot have a heap")} }, if (self.SEGZERO.iAllocHeap == 1) {self.SEGZERO.iReqHeapCount++} else {$d = self.error("Segment for DSP/BIOS objects must be a memory segment with a heap")}, if (self.MALLOCSEG.iAllocHeap == 1) {self.MALLOCSEG.iReqHeapCount++} else {$d = self.error("Segment for malloc()/free() must be a memory segment with a heap")}, $d)
    prop _page :: (self.page)
    prop _origin :: (self.base)
    prop _len :: (self.len)
    prop maxObjs :: (32767)
    prop codeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {(($1.space == "code") || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 54 {($1.space == "code")} else {if GBL.DSPTYPE == 28 {($1.space == "code" || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 55 {(($1.space == "code") || ($1.space == "code/data"))} else {($1.space == "code/data")}}}}})
    prop dataMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {if GBL.DSPTYPE == 28 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {(($1.space == "code/data") && ($1 != MEM_NULL))}}}}})
    prop dataNullMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 54 {$1.space != "code" && $1.space != "io"} else {if GBL.DSPTYPE == 28 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 55 {$1.space == "data" || $1.space == "code/data"} else {$1.space == "code/data"}}}}})
    prop dataCodeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {$1.space == "code" && $1 != MEM_NULL} else {if GBL.DSPTYPE == 28 {($1.space == "code" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {$1.space == "code/data" && $1 != MEM_NULL}}}}})
    prop memWritable :: (self.iIsModifiable && self.iDelUser != "MEM")
    prop validate :: ($e = self.checkMemOverlap($1), if ($e == "ok") {$e = self.checkHeapSize($1)} , if ($e == "ok") {$e = self.checkHeapSeg($1)} , $e)
    prop checkHeapSeg :: ($e = "ok", if ($1 == MEM_NULL && MEM.NOHEAPS == 0) {if (MEM.MALLOCSEG == MEM_NULL) {$e = ("Heaps are enabled, but the segment for malloc (MEM.MALLOCSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.MALLOCSEG to it.")} , if (MEM.SEGZERO == MEM_NULL) {$e = ("Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.")} } , $e)
    prop checkHeapSize :: ($e = "ok", if (MEM.NOHEAPS == 0) {if ($1.iAllocHeap && $1 != MEM_NULL) {if ($1.iHeapSize > $1.len) {$e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")} } } , $e)
    prop checkMemOverlap :: ($e = "ok", if ($1 != MEM_NULL && $1.iIsUsed == 1) {if ($1.len == 0) {$a = $1.base} else {$a = ($1.base + $1.len - 1)}, scan ($j; MEM) {if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 && (GBL.DSPTYPE == 62 || $1.space == $j.space)) {if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {$b = $j.base, if ($j.len == 0) {$c = $j.base} else {$c = ($j.base + $j.len - 1)}, if ($a >= $b && $1.base <= $c) {$e = ("MEM segment %s: overlaps with another segment or cache configuration."), break} } } }} , $e)
    prop _spaceEnum :: (self.ENUMSPACE)
    prop checkHeapId :: ($e = "ok", scan ($i; MEM) {if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {$e = self.error("This identifier label is already in use"), break} }, $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap :: = ($a = 0, scan ($i; MEM) {if ($i != MEM_NULL) {$a += $i.iAllocHeap} }, $a) { 
        prop NoGen :: 0
    }
    global REUSE :: = (if self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1 {self.SAVEREUSE} else {0}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reuse Startup Code Space"
        prop JSName :: "REUSECODESPACE"
        prop Visible :: 1
        prop Writable :: self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1
        prop NoGen :: 1
        prop Set :: (self.SAVEREUSE = $1, "ok")
    }
    global SAVEREUSE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    global doCheckOverlap :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MAPSELECT :: "Map 1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Map Mode"
        prop JSName :: "MAPMODE"
        prop Enum :: "Map 0,Map 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ARGSSIZE :: 4 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Argument Buffer Size"
        prop JSName :: "ARGSSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("The 'arguments' section must have at least 4 words.")} else {self.ARGSSIZE = $1, "ok"})
    }
    global ARGSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Argument Buffer Section (.args)"
        prop JSName :: "ARGSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global BIOSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "BIOS Code Section (.bios)"
        prop JSName :: "BIOSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: if GBL.DSPTYPE == 54 {0x01 | 0x02} else {0x02}
        prop Label :: "Stack Size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {self.STACKSIZE = ($1 & -2)} else {if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE == 5599)) {self.STACKSIZE = ($1 & -4)} else {self.STACKSIZE = $1}}, "ok")
        prop PropSetOkUserMsg :: if (MEM.STACKSIZE < GlobalStatus.MinStackSize) {"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!"} else {"ok"}
    }
    global USERCMD :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User .cmd File For Compiler Sections"
        prop JSName :: "USERCOMMANDFILE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Stack Section (.stack)"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global ENABLELOADSEG :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
        prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - BIOS Code Section (.bios)"
        prop JSName :: "LOADBIOSSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global INITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Startup Code Section (.sysinit)"
        prop JSName :: "SYSINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - Startup Code Section (.sysinit)"
        prop JSName :: "LOADSYSINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "GBLINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "TRC Initial Value (.trcdata)"
        prop JSName :: "TRCDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "LOADGBLINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - TRC Initial Value (.trcdata)"
        prop JSName :: "LOADTRCDATASEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SYSDATASEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Kernel State (.sysdata)"
        prop JSName :: "SYSDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
        prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No Dynamic Memory Heaps"
        prop JSName :: "NOMEMORYHEAPS"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.SEGZERO.iReqHeapCount--, self.SEGZERO = MEM_NULL, self.MALLOCSEG.iReqHeapCount--, self.MALLOCSEG = MEM_NULL, TSK.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, scan ($i; MEM) {if ($i.iAllocHeap && $i != MEM_NULL) {$i.iAllocHeap = 0, $i.iHeapSize = 0} }} , self.NOHEAPS = $1, "ok")
        prop PropSetOkUserMsg :: if (MEM.NOHEAPS == 1) {"Currently specified heaps no longer valid"} else {"Please reconfigure heaps under individual mem segments"}
    }
    global SEGZERO :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For DSP/BIOS Objects"
        prop JSName :: "BIOSOBJSEG"
        prop Visible :: 1
        prop Writable :: MEM.NOHEAPS == 0
        prop NoGen :: 0
        prop Set :: (if (self.SEGZERO.iReqHeapCount > 0) {self.SEGZERO.iReqHeapCount--} , self.SEGZERO = $1, self.SEGZERO.iReqHeapCount++, "ok")
    }
    global MALLOCSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
        prop JSName :: "MALLOCSEG"
        prop Visible :: 1
        prop Writable :: (MEM.NOHEAPS == 0)
        prop NoGen :: 0
        prop Set :: (if (self.MALLOCSEG.iReqHeapCount > 0) {self.MALLOCSEG.iReqHeapCount--} , self.MALLOCSEG = $1, self.MALLOCSEG.iReqHeapCount++, "ok")
    }
    global USEMPC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Memory Protection Controller module"
        prop JSName :: "USEMPC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global LNKCMDFILE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TEXTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Text Section (.text)"
        prop JSName :: "TEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Load Address - Text Section (.text)"
        prop JSName :: "LOADTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SWITCHSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Switch Jump Tables (.switch)"
        prop JSName :: "SWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Switch Jump Tables (.switch)"
        prop JSName :: "LOADSWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BSSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.bss)"
        prop JSName :: "BSSSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global FARSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.far)"
        prop JSName :: "FARSEG"
        prop Visible :: if GBL.DSPTYPE == 62 {1} else {0}
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Data Initialization Section (.cinit)"
        prop JSName :: "CINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Data Initialization Section (.cinit)"
        prop JSName :: "LOADCINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global PINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "C Function Initialization Table (.pinit)"
        prop JSName :: "PINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADPINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - C Function Initialization Table (.pinit)"
        prop JSName :: "LOADPINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global CONSTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Constant Sections (.const, .printf)"
        prop JSName :: "CONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Load Address - Constant Sections (.const, .printf)"
        prop JSName :: "LOADCONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global DATASEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.data)"
        prop JSName :: "DATASEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.cio)"
        prop JSName :: "CIOSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
        prop Set :: (self.CIOSEG = $1, self.SYSMEMSEG = $1, "ok")
    }
    global SYSMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.sysmem)"
        prop JSName :: "SYSMEMSEG"
        prop Visible :: 0
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory (.hwi)"
        prop JSName :: "HWISEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.STUBMEMSEG = $1, HWI.STUBMEMSEG = $1, "ok")
    }
    global LOADSTUBMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - Function Stub Memory (.hwi)"
        prop JSName :: "LOADHWISEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global VECMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "HWIVECSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.VECMEMSEG = $1, HWI.VECMEMSEG = $1, GlobalStatus.gDirty = 1, if ($1.base == 0) {HWI.GENERATE_RESET_VEC = 0} , "ok")
    }
    global LOADVECMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "LOADHWIVECSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop JSName :: "RTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.RTDXTEXTMEMSEG = $1, RTDX.TEXTMEMSEG = $1, "ok")
    }
    global LOADRTDXTEXTMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
        prop JSName :: "LOADRTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global ENUMSPACE :: = if GBL.DSPTYPE == 62 {"code,data,code/data,reserved"} else {if GBL.DSPTYPE == 54 {"code,data,io,other,reserved"} else {if GBL.DSPTYPE == 28 {"code,code/data,data,io,other,reserved"} else {if GBL.DSPTYPE == 55 {"code/data,code,data,io,reserved"} else {"code/data,io,reserved"}}}} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "ENUMSPACE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst base :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%06x"}
        prop Style :: 0x02
        prop Label :: "base"
        prop JSName :: "base"
        prop Visible :: 1
        prop Writable :: (self.iIsModifiable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", $a = self.base, self.base = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.base = $a} } , $e)
    }
    inst len :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x08
        prop Label :: "len"
        prop JSName :: "len"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 0
        prop Set :: ($e = "ok", $a = self.len, self.len = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.len = $a} } , "ok")
    }
    inst page :: = (if GBL.DSPTYPE == 62 {-1} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {0}}})} else {if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {3}}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iAllocHeap :: if MEM.NOHEAPS == 1 {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
        prop JSName :: "createHeap"
        prop Visible :: 1
        prop Writable :: (self.space == "data" || self.space == "code/data") && (MEM.NOHEAPS == 0) && self.memWritable
        prop NoGen :: 0
        prop Set :: ($a = "ok", if ($1 == 0 && self.iReqHeapCount > 0) {self.error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")} else {if ($1 == 0) {self.iUserHeapId = 0, self.iHeapId = @segment_name} , self.iAllocHeap = $1, MEM.gDirty = 1, $a})
    }
    inst iHeapSize :: 0x8000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x02
        prop Label :: "heap size"
        prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (self.iHeapSize = $1, "ok")
        prop NoGen :: 1
    }
    inst iSegZero :: = MEM.SEGZERO
    inst iUserHeapId :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "enter a user defined heap identifier label"
        prop JSName :: "enableHeapLabel"
        prop Set :: (if ($1 == 0) {self.iHeapId = @segment_name} , self.iUserHeapId = $1, "ok")
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0)
        prop NoGen :: 1
    }
    inst iHeapId :: @segment_name { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "heap identifier label"
        prop JSName :: "heapLabel"
        prop Set :: ($e = self.checkHeapId($1), if ($e == "ok") {self.iHeapId = $1} , $e)
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0) && (self.iUserHeapId)
        prop Visible :: 1
        prop NoGen :: 0
    }
    inst iReqHeapCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst space :: (if GBL.DSPTYPE == 55 {"code/data"} else {"data"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: MEM._spaceEnum()
        prop JSName :: "space"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 != "data" && $1 != "code/data" && self.iAllocHeap == 1) {$e = self.error("Cannot select this space if a heap will be created")} else {$a = self.space, self.space = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.space = $a} } }, $e)
    }
    inst dynamicLoading :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reserved for dynamic loading"
        prop JSName :: "dynamicLoading"
        prop Visible :: GBL.ENABLEDLL
        prop Writable :: GBL.ENABLEDLL
        prop NoGen :: 1
    }
    inst iIsModifiable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 0
    param len :: 0
    param iAllocHeap :: 1
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _objMemDesc, _memSeg, _placement"} )
    prop _objMemDesc :: ("%8t .obj: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type BUF {
    isa ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer Manager"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (421)
    prop GlobalHelpTopic :: (321)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,      _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t.buf:{}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$data: align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength")
    prop _objAlign :: self.align
    prop _instMemSeg :: self.bufseg
    prop _buflength :: (self.postalignsize * self.bufcount)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"buf.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far BUF_Obj %0r;\n\0"} else {"extern BUF_Obj %0r;\n\0"})
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = ((7 + 3) * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = ((7 + 4) * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = ((7 + 3) * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (7 + 4)} , if (GBL.DSPTYPE == 28) {$a = (12 + 6)} , $a)
    prop dataSize :: ($d = 0, scan ($i; BUF) {if ($i.IsConfObj()) {$d += $i.len} , $d += BUF.objectSize}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
